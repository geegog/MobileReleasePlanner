IMPORT pandas as pd

IMPORT numpy as np

IMPORT random

IMPORT copy



from planner IMPORT base





DEFINE CLASS LP(base.MobileReleasePlanner):

    """Mobile Release Planning using Linear Programming."""



    DEFINE FUNCTION __init__(self, stakeholder_importance=None, release_relative_importance=None, release_duration=None,

                 coupling=None, highest=True, shuffle=True, is_sorted=False):



        """

        Initialize a linear programming/greedy algorithm.



        :type shuffle: bool

        :param shuffle (bool): Shuffle features.



        :type is_sorted: bool

        :param is_sorted (bool): Sort features IN descending order based on WAS of 1st release.



        :type stakeholder_importance:(int, int)

        :param stakeholder_importance (tuple): Stakeholders importance.



        :type release_relative_importance: (float, float, float)

        :param release_relative_importance: Release relative importance.



        :type release_duration : int

        :param release_duration: Release duration.



        :type coupling: {(str, str)}

        :param coupling: Coupled features.



        :type highest: bool

        :param highest: Flag specified IF feature should be chosen randomly or based on the highest WAS.

        """



        SET self.delete_flag TO False

        SET self.highest TO highest

        SET self.shuffle TO shuffle

        SET self.is_sorted TO is_sorted



        super(LP, self).__init__(stakeholder_importance, release_relative_importance, release_duration, coupling)



    DEFINE FUNCTION assignment_function(self, array_was_feature):

        """

        Greedy function FOR feature assignment.



        :type array_was_feature: list

        :param array_was_feature: Release and WAS FOR a feature

        """



        SET original_feature_set TO copy.copy(array_was_feature)

        IF self.shuffle:

            random.shuffle(array_was_feature)

        IF self.is_sorted:

            sorted(array_was_feature, key=lambda f: f[0][1], reverse=True)

        FOR feature_array IN array_was_feature:

            IF feature_array is not None:

                IF self.highest:

                    SET max_feature TO self.get_max_was(feature_array)

                ELSE:

                    SET max_feature TO self.get_random_was(feature_array)

                SET couple_key TO self.is_coupled_with(max_feature[2])

                IF couple_key is not None:

                    SET feature TO [(idx, feature) FOR idx, feature IN enumerate(array_was_feature) IF

                               (feature is not None and feature[0][2] EQUALS couple_key)]

                    IF self.highest:

                        SET partner TO self.get_max_was(feature[0][1])

                    ELSE:

                        SET partner TO self.get_random_was(feature[0][1])

                    SET total_effort TO self.sum_couple_effort(max_feature[4], partner[4])

                    self.assign(max_feature, feature_array, total_effort, partner,

                                array_was_feature[feature[0][0]])

                    IF self.delete_flag:

                        SET index TO [idx FOR idx, f IN enumerate(array_was_feature) IF

                                 (f is not None and f[0][2] EQUALS couple_key)]

                        SET array_was_feature[index[0]] TO None

                        SET self.delete_flag TO False

                ELSE:

                    self.assign(max_feature, feature_array)



    DEFINE FUNCTION assign(self, max_feature, feature_array, total_effort=None, couple=None, couple_array=None):

        """

        Assigns a feature to a mobile release plan or put IN not feasible list IF not feasible IN current plan.



        :param max_feature: Feature with highest WAS

        :type max_feature: list

        :param feature_array: Feature details

        :type feature_array: list

        :param total_effort: Total effort estimate of coupled features

        :type total_effort: float

        :param couple: Feature partner (couple)

        :type couple: tuple

        :param couple_array: Couple details

        :type couple_array: list

        """



        IF self.can_assign_to_release(self.effort_release_1, max_feature[4], total_effort):

            IF couple is not None:

                self.append_to_release(1, max_feature[1], max_feature[2], max_feature[3], max_feature[4], couple)

                SET self.delete_flag TO True

            ELSE:

                self.append_to_release(1, max_feature[1], max_feature[2], max_feature[3], max_feature[4])

        ELSEIF self.can_assign_to_release(self.effort_release_2, max_feature[4], total_effort):

            IF couple is not None:

                self.append_to_release(2, max_feature[1], max_feature[2], max_feature[3], max_feature[4], couple)

                SET self.delete_flag TO True

            ELSE:

                self.append_to_release(2, max_feature[1], max_feature[2], max_feature[3], max_feature[4])

        ELSEIF self.can_assign_to_release(self.effort_release_3, max_feature[4], total_effort):

            IF couple is not None:

                self.append_to_release(3, max_feature[1], max_feature[2], max_feature[3], max_feature[4], couple)

                SET self.delete_flag TO True

            ELSE:

                self.append_to_release(3, max_feature[1], max_feature[2], max_feature[3], max_feature[4])

        ELSE:

            IF couple is not None:

                self.append_to_release(4, max_feature[1], max_feature[2], max_feature[3], max_feature[4], couple)

                SET self.delete_flag TO True

            ELSE:

                self.append_to_release(4, max_feature[1], max_feature[2], max_feature[3], max_feature[4])





DEFINE FUNCTION main():

    SET coupling TO {("F7", "F8"), ("F9", "F12"), ("F13", "F14")}



    SET si TO [(4, 6), (6, 4)]

    SET rrp TO [(0.3, 0.3, 0.3), (0.8, 0.1, 0.1), (0.1, 0.8, 0.1), (0.1, 0.1, 0.8)]

    SET ds TO [50, 300, 700]

    SET heading TO ['Release', 'WAS', 'Key', 'Feature', 'Effort (Story Point)']



    FOR d IN ds:

        FOR i IN si:

            FOR ri IN rrp:



                SET lp TO LP(coupling=None, stakeholder_importance=i, release_relative_importance=ri,

                        release_duration=d, is_sorted=True)



                SET features TO lp.features()



                SET # data TO np.array(features)

                SET # result TO pd.DataFrame(data=data)

                # OUTPUT(result)



                lp.assignment_function(features)



                SET mrp TO lp.mobile_release_plan



                SET rows TO []



                FOR r IN mrp:

                    rows.append([r[0], r[1], r[2], r[3], r[4]])

                SET obj_score TO lp.objective_function(lp.mobile_release_plan)



                OUTPUT('Effort R1: ' + str(lp.effort_release_1),

                      'Effort R2: ' + str(lp.effort_release_2),

                      'Effort R3: ' + str(lp.effort_release_3),

                      'D: ' + str(d) + ' S: ' + ''.join(

                          str(i)) + ' ξ(n): ' + ''.join(str(ri)),

                      'Objective Function: ' + str(obj_score))



                rows.append(['', 'Effort R1: ' + str(lp.effort_release_1),

                             'Effort R2: ' + str(lp.effort_release_2),

                             'Effort R3: ' + str(lp.effort_release_3),

                             'F(x): ' + str(obj_score)])

                rows.append(['', '', 'D: ' + str(d), 'S: ' + ''.join(

                                 str(i)), 'ξ(n): ' + ''.join(str(ri))])

                SET df2 TO pd.DataFrame(np.array(rows),

                                   columns=heading)



                df2.to_csv('lp-results/' + 'duration-' + str(d) + '-stakeholder_importance-' + ''.join(

                    str(i)) + '-release_relative_importance-' + ''.join(str(ri)) + '.csv')





IF __name__ EQUALS "__main__":

    main()

